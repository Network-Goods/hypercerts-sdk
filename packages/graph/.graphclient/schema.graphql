schema {
  query: Query
  subscription: Subscription
}

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type Contributor {
  """contibutor ID is an Ethereum address"""
  id: ID!
  """hypercert the contributor has contributed to"""
  hypercerts(skip: Int = 0, first: Int = 100, orderBy: Hypercert_orderBy, orderDirection: OrderDirection, where: Hypercert_filter): [Hypercert!]!
}

input Contributor_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  hypercerts_: Hypercert_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Contributor_orderBy {
  id
  hypercerts
}

type Hypercert {
  """
  hypercert ID maps to the uint256 slotID in the ERC3525 Hypercert Minter
  """
  id: ID!
  """fingerprint of the hyperspace claimed by the minter"""
  claimHash: Bytes!
  """address of the entity claiming the impact"""
  minter: String!
  """array of know addresses representing contributors to this impact claim"""
  contributors(skip: Int = 0, first: Int = 100, orderBy: Contributor_orderBy, orderDirection: OrderDirection, where: Contributor_filter): [Contributor!]!
  """unix timestamp declaring when impact started"""
  impactDateFrom: BigInt!
  """unix timestamp declaring when impact ended"""
  impactDateTo: BigInt!
  """array of impacts declared in claim"""
  impactScopes(skip: Int = 0, first: Int = 100, orderBy: ImpactScope_orderBy, orderDirection: OrderDirection, where: ImpactScope_filter): [ImpactScope!]!
  """unix timestamp declaring when work started"""
  workDateFrom: BigInt!
  """unix timestamp declaring when work ended"""
  workDateTo: BigInt!
  """array of work declared in claim"""
  workScopes(skip: Int = 0, first: Int = 100, orderBy: WorkScope_orderBy, orderDirection: OrderDirection, where: WorkScope_filter): [WorkScope!]!
  """array of rights an owner of the impact certificate holds"""
  rights(skip: Int = 0, first: Int = 100, orderBy: Right_orderBy, orderDirection: OrderDirection, where: Right_filter): [Right!]!
  """external reference, usually IPFS CID"""
  uri: String!
  """base64 formatted json string including SVG image"""
  metadata: String!
  """total unit of certificate, used for splitting and merging"""
  totalUnits: BigInt!
  """fractions of certificate"""
  fractions(skip: Int = 0, first: Int = 100, orderBy: HypercertFraction_orderBy, orderDirection: OrderDirection, where: HypercertFraction_filter): [HypercertFraction!]!
  """unix timestamp of last change to entity"""
  lastUpdated: BigInt!
  """hypercert version"""
  version: BigInt!
}

type HypercertFraction {
  """
  fraction ID maps to the uint256 tokenID in the ERC3525 Hypercert Minter
  """
  id: ID!
  """address of the entity owning the impact"""
  owner: Owner!
  """units held by the fraction, used for splitting and merging"""
  units: BigInt!
  """link to hypercert this fraction relates to"""
  hypercert: Hypercert!
}

input HypercertFraction_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  owner: String
  owner_not: String
  owner_gt: String
  owner_lt: String
  owner_gte: String
  owner_lte: String
  owner_in: [String!]
  owner_not_in: [String!]
  owner_contains: String
  owner_contains_nocase: String
  owner_not_contains: String
  owner_not_contains_nocase: String
  owner_starts_with: String
  owner_starts_with_nocase: String
  owner_not_starts_with: String
  owner_not_starts_with_nocase: String
  owner_ends_with: String
  owner_ends_with_nocase: String
  owner_not_ends_with: String
  owner_not_ends_with_nocase: String
  owner_: Owner_filter
  units: BigInt
  units_not: BigInt
  units_gt: BigInt
  units_lt: BigInt
  units_gte: BigInt
  units_lte: BigInt
  units_in: [BigInt!]
  units_not_in: [BigInt!]
  hypercert: String
  hypercert_not: String
  hypercert_gt: String
  hypercert_lt: String
  hypercert_gte: String
  hypercert_lte: String
  hypercert_in: [String!]
  hypercert_not_in: [String!]
  hypercert_contains: String
  hypercert_contains_nocase: String
  hypercert_not_contains: String
  hypercert_not_contains_nocase: String
  hypercert_starts_with: String
  hypercert_starts_with_nocase: String
  hypercert_not_starts_with: String
  hypercert_not_starts_with_nocase: String
  hypercert_ends_with: String
  hypercert_ends_with_nocase: String
  hypercert_not_ends_with: String
  hypercert_not_ends_with_nocase: String
  hypercert_: Hypercert_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum HypercertFraction_orderBy {
  id
  owner
  units
  hypercert
}

input Hypercert_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  claimHash: Bytes
  claimHash_not: Bytes
  claimHash_in: [Bytes!]
  claimHash_not_in: [Bytes!]
  claimHash_contains: Bytes
  claimHash_not_contains: Bytes
  minter: String
  minter_not: String
  minter_gt: String
  minter_lt: String
  minter_gte: String
  minter_lte: String
  minter_in: [String!]
  minter_not_in: [String!]
  minter_contains: String
  minter_contains_nocase: String
  minter_not_contains: String
  minter_not_contains_nocase: String
  minter_starts_with: String
  minter_starts_with_nocase: String
  minter_not_starts_with: String
  minter_not_starts_with_nocase: String
  minter_ends_with: String
  minter_ends_with_nocase: String
  minter_not_ends_with: String
  minter_not_ends_with_nocase: String
  contributors: [String!]
  contributors_not: [String!]
  contributors_contains: [String!]
  contributors_contains_nocase: [String!]
  contributors_not_contains: [String!]
  contributors_not_contains_nocase: [String!]
  contributors_: Contributor_filter
  impactDateFrom: BigInt
  impactDateFrom_not: BigInt
  impactDateFrom_gt: BigInt
  impactDateFrom_lt: BigInt
  impactDateFrom_gte: BigInt
  impactDateFrom_lte: BigInt
  impactDateFrom_in: [BigInt!]
  impactDateFrom_not_in: [BigInt!]
  impactDateTo: BigInt
  impactDateTo_not: BigInt
  impactDateTo_gt: BigInt
  impactDateTo_lt: BigInt
  impactDateTo_gte: BigInt
  impactDateTo_lte: BigInt
  impactDateTo_in: [BigInt!]
  impactDateTo_not_in: [BigInt!]
  impactScopes: [String!]
  impactScopes_not: [String!]
  impactScopes_contains: [String!]
  impactScopes_contains_nocase: [String!]
  impactScopes_not_contains: [String!]
  impactScopes_not_contains_nocase: [String!]
  impactScopes_: ImpactScope_filter
  workDateFrom: BigInt
  workDateFrom_not: BigInt
  workDateFrom_gt: BigInt
  workDateFrom_lt: BigInt
  workDateFrom_gte: BigInt
  workDateFrom_lte: BigInt
  workDateFrom_in: [BigInt!]
  workDateFrom_not_in: [BigInt!]
  workDateTo: BigInt
  workDateTo_not: BigInt
  workDateTo_gt: BigInt
  workDateTo_lt: BigInt
  workDateTo_gte: BigInt
  workDateTo_lte: BigInt
  workDateTo_in: [BigInt!]
  workDateTo_not_in: [BigInt!]
  workScopes: [String!]
  workScopes_not: [String!]
  workScopes_contains: [String!]
  workScopes_contains_nocase: [String!]
  workScopes_not_contains: [String!]
  workScopes_not_contains_nocase: [String!]
  workScopes_: WorkScope_filter
  rights: [String!]
  rights_not: [String!]
  rights_contains: [String!]
  rights_contains_nocase: [String!]
  rights_not_contains: [String!]
  rights_not_contains_nocase: [String!]
  rights_: Right_filter
  uri: String
  uri_not: String
  uri_gt: String
  uri_lt: String
  uri_gte: String
  uri_lte: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_contains: String
  uri_contains_nocase: String
  uri_not_contains: String
  uri_not_contains_nocase: String
  uri_starts_with: String
  uri_starts_with_nocase: String
  uri_not_starts_with: String
  uri_not_starts_with_nocase: String
  uri_ends_with: String
  uri_ends_with_nocase: String
  uri_not_ends_with: String
  uri_not_ends_with_nocase: String
  metadata: String
  metadata_not: String
  metadata_gt: String
  metadata_lt: String
  metadata_gte: String
  metadata_lte: String
  metadata_in: [String!]
  metadata_not_in: [String!]
  metadata_contains: String
  metadata_contains_nocase: String
  metadata_not_contains: String
  metadata_not_contains_nocase: String
  metadata_starts_with: String
  metadata_starts_with_nocase: String
  metadata_not_starts_with: String
  metadata_not_starts_with_nocase: String
  metadata_ends_with: String
  metadata_ends_with_nocase: String
  metadata_not_ends_with: String
  metadata_not_ends_with_nocase: String
  totalUnits: BigInt
  totalUnits_not: BigInt
  totalUnits_gt: BigInt
  totalUnits_lt: BigInt
  totalUnits_gte: BigInt
  totalUnits_lte: BigInt
  totalUnits_in: [BigInt!]
  totalUnits_not_in: [BigInt!]
  fractions_: HypercertFraction_filter
  lastUpdated: BigInt
  lastUpdated_not: BigInt
  lastUpdated_gt: BigInt
  lastUpdated_lt: BigInt
  lastUpdated_gte: BigInt
  lastUpdated_lte: BigInt
  lastUpdated_in: [BigInt!]
  lastUpdated_not_in: [BigInt!]
  version: BigInt
  version_not: BigInt
  version_gt: BigInt
  version_lt: BigInt
  version_gte: BigInt
  version_lte: BigInt
  version_in: [BigInt!]
  version_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Hypercert_orderBy {
  id
  claimHash
  minter
  contributors
  impactDateFrom
  impactDateTo
  impactScopes
  workDateFrom
  workDateTo
  workScopes
  rights
  uri
  metadata
  totalUnits
  fractions
  lastUpdated
  version
}

type ImpactScope {
  """
  impaceScope ID maps to byts32 input of 'impactScopes' on Hypercert Minter
  """
  id: ID!
  """natural language description of impact scope"""
  text: String!
  """array of hypercerts claiming this type of impact"""
  hypercerts(skip: Int = 0, first: Int = 100, orderBy: Hypercert_orderBy, orderDirection: OrderDirection, where: Hypercert_filter): [Hypercert!]!
}

input ImpactScope_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  text: String
  text_not: String
  text_gt: String
  text_lt: String
  text_gte: String
  text_lte: String
  text_in: [String!]
  text_not_in: [String!]
  text_contains: String
  text_contains_nocase: String
  text_not_contains: String
  text_not_contains_nocase: String
  text_starts_with: String
  text_starts_with_nocase: String
  text_not_starts_with: String
  text_not_starts_with_nocase: String
  text_ends_with: String
  text_ends_with_nocase: String
  text_not_ends_with: String
  text_not_ends_with_nocase: String
  hypercerts_: Hypercert_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum ImpactScope_orderBy {
  id
  text
  hypercerts
}

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type Owner {
  """owner ID is an Ethereum address"""
  id: ID!
}

input Owner_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Owner_orderBy {
  id
}

type Query {
  contributor(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Contributor
  contributors(
    skip: Int = 0
    first: Int = 100
    orderBy: Contributor_orderBy
    orderDirection: OrderDirection
    where: Contributor_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Contributor!]!
  owner(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Owner
  owners(
    skip: Int = 0
    first: Int = 100
    orderBy: Owner_orderBy
    orderDirection: OrderDirection
    where: Owner_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Owner!]!
  hypercert(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Hypercert
  hypercerts(
    skip: Int = 0
    first: Int = 100
    orderBy: Hypercert_orderBy
    orderDirection: OrderDirection
    where: Hypercert_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Hypercert!]!
  hypercertFraction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HypercertFraction
  hypercertFractions(
    skip: Int = 0
    first: Int = 100
    orderBy: HypercertFraction_orderBy
    orderDirection: OrderDirection
    where: HypercertFraction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HypercertFraction!]!
  impactScope(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ImpactScope
  impactScopes(
    skip: Int = 0
    first: Int = 100
    orderBy: ImpactScope_orderBy
    orderDirection: OrderDirection
    where: ImpactScope_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ImpactScope!]!
  workScope(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WorkScope
  workScopes(
    skip: Int = 0
    first: Int = 100
    orderBy: WorkScope_orderBy
    orderDirection: OrderDirection
    where: WorkScope_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WorkScope!]!
  right(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Right
  rights(
    skip: Int = 0
    first: Int = 100
    orderBy: Right_orderBy
    orderDirection: OrderDirection
    where: Right_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Right!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Right {
  """impaceScope ID maps to bytes32 input of 'rights' on Hypercert Minter"""
  id: ID!
  """natural language description of rights the owner holds"""
  text: String!
  """array of hypercerts claiming these type of rights"""
  hypercerts(skip: Int = 0, first: Int = 100, orderBy: Hypercert_orderBy, orderDirection: OrderDirection, where: Hypercert_filter): [Hypercert!]!
}

input Right_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  text: String
  text_not: String
  text_gt: String
  text_lt: String
  text_gte: String
  text_lte: String
  text_in: [String!]
  text_not_in: [String!]
  text_contains: String
  text_contains_nocase: String
  text_not_contains: String
  text_not_contains_nocase: String
  text_starts_with: String
  text_starts_with_nocase: String
  text_not_starts_with: String
  text_not_starts_with_nocase: String
  text_ends_with: String
  text_ends_with_nocase: String
  text_not_ends_with: String
  text_not_ends_with_nocase: String
  hypercerts_: Hypercert_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum Right_orderBy {
  id
  text
  hypercerts
}

type Subscription {
  contributor(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Contributor
  contributors(
    skip: Int = 0
    first: Int = 100
    orderBy: Contributor_orderBy
    orderDirection: OrderDirection
    where: Contributor_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Contributor!]!
  owner(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Owner
  owners(
    skip: Int = 0
    first: Int = 100
    orderBy: Owner_orderBy
    orderDirection: OrderDirection
    where: Owner_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Owner!]!
  hypercert(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Hypercert
  hypercerts(
    skip: Int = 0
    first: Int = 100
    orderBy: Hypercert_orderBy
    orderDirection: OrderDirection
    where: Hypercert_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Hypercert!]!
  hypercertFraction(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): HypercertFraction
  hypercertFractions(
    skip: Int = 0
    first: Int = 100
    orderBy: HypercertFraction_orderBy
    orderDirection: OrderDirection
    where: HypercertFraction_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [HypercertFraction!]!
  impactScope(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): ImpactScope
  impactScopes(
    skip: Int = 0
    first: Int = 100
    orderBy: ImpactScope_orderBy
    orderDirection: OrderDirection
    where: ImpactScope_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [ImpactScope!]!
  workScope(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): WorkScope
  workScopes(
    skip: Int = 0
    first: Int = 100
    orderBy: WorkScope_orderBy
    orderDirection: OrderDirection
    where: WorkScope_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [WorkScope!]!
  right(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): Right
  rights(
    skip: Int = 0
    first: Int = 100
    orderBy: Right_orderBy
    orderDirection: OrderDirection
    where: Right_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [Right!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type WorkScope {
  """
  impaceScope ID maps to bytes32 input of 'workScopes' on Hypercert Minter
  """
  id: ID!
  """natural language description of work scope"""
  text: String!
  """array of hypercerts claiming this type of work"""
  hypercerts(skip: Int = 0, first: Int = 100, orderBy: Hypercert_orderBy, orderDirection: OrderDirection, where: Hypercert_filter): [Hypercert!]!
}

input WorkScope_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  text: String
  text_not: String
  text_gt: String
  text_lt: String
  text_gte: String
  text_lte: String
  text_in: [String!]
  text_not_in: [String!]
  text_contains: String
  text_contains_nocase: String
  text_not_contains: String
  text_not_contains_nocase: String
  text_starts_with: String
  text_starts_with_nocase: String
  text_not_starts_with: String
  text_not_starts_with_nocase: String
  text_ends_with: String
  text_ends_with_nocase: String
  text_not_ends_with: String
  text_not_ends_with_nocase: String
  hypercerts_: Hypercert_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
}

enum WorkScope_orderBy {
  id
  text
  hypercerts
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}